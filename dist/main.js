class e{constructor(){this.events={}}on(e,t){return this.events[e]||(this.events[e]=[]),this.events[e].push(t),()=>{this.events[e]=this.events[e].filter((e=>t!==e))}}getListeners(e){return this.events[e]}off(e,t){if(!e)return void(this.events={});let s=this.events[e];s&&(t?this.events[e]=s.filter((e=>t!==e)):delete this.events[e])}once(e,t){let s;return this.on(e,s=n=>{t.call(null,n),this.events[e]=this.events[e].filter((e=>s!==e))})}emit(e,t){let s=this.events[e];s&&s.forEach((e=>e.call(null,t)))}}class t extends Error{}class s extends t{constructor(e){super(`Handshake has timed out after ${e}ms. There was no message received from the other side`)}}class n extends t{constructor(e){super(`Message name "${e}" is reserved for internal use`)}}class a extends t{constructor(e){super(`callback has timed out after ${e}ms. There was no callback message received from the other side`)}}class i extends t{constructor(){super("fetch abort error")}}var r="___handshake___",h="message";function o(e,t,s=0){e.push(t),s&&e.length>s&&e.shift()}function c(e,t){let s=0;for(;e.length>s;){const n=e.shift();n&&!1===t(n)&&(e.push(n),s++)}return s}class d{constructor(e,t){let s=(n=e,"[object Object]"===Object.prototype.toString.call(n)?e:{name:e,data:t});var n;this.__bridge_payload__=!0,this.timestamp=Date.now(),this.name=s.name,this.data=s.data}static createAndValidate(e,t){let s=new d(e,t);if(s.name===h||s.name===r)throw new n(s.name);return s}static createHandshake(){return new d(r)}}var l={targetWindow:null,origin:"*",handshakeInterval:200,handshakeTimeout:5e3,queueLimit:100,callbackTimeout:5e3};class u extends e{constructor(e){super(),this.option=Object.assign({},l,e),this.targetWindow=this.option.targetWindow,this.listenWindow=this.option.listenWindow||window,this.connected=!1,this.connectedPromise=null,this.handshakeQueue=[],this.send=this.postMessage,this.option.proxyMode?this.namespace=this.option.namespace:(this.receiveMessage=this.receiveMessage.bind(this),this.listenWindow.addEventListener("message",this.receiveMessage,!1))}connect(){return this.connected?Promise.resolve():(this.connectedPromise||(this.connectedPromise=new Promise(((e,t)=>{this.tryHandshake(e,t)}))),this.connectedPromise)}tryHandshake(e,t){this.handleHandshakeResponse(e)}handleHandshakeResponse(e){this.handshakeResponseHandler=t=>{this.connectDone(e,t)}}connectDone(e,t){this.connected=!0,this.connectedPromise=null,this.handshakeResponseHandler=null,e()}handshake(){this.doPostMessage(d.createHandshake())}postMessage(e,t){const s=d.createAndValidate(e,t);if(this.connected)return this.doPostMessage(s);o(this.handshakeQueue,s,this.option.queueLimit)}doPostMessage(e){const t=JSON.stringify(e);this.targetWindow.postMessage(t,this.option.origin)}receiveMessage(e){let t;try{t=JSON.parse(e.data)}catch(e){return!1}return!!t.__bridge_payload__&&(t.name===r?(this.handshakeResponseHandler&&this.handshakeResponseHandler(e),!1):t)}destroy(){this.option.proxyMode||this.listenWindow.removeEventListener("message",this.receiveMessage,!1)}}class p extends u{constructor(e){super(e),delete this.option.targetWindow}tryHandshake(e,t){super.tryHandshake(e,t),this.handshake(),this.handshakeInterval=setInterval((()=>{this.handshake()}),this.option.handshakeInterval),this.handshakeTimeout=setTimeout((()=>{clearInterval(this.handshakeInterval),this.initPromise=null,this.handshakeResponseHandler=null,t(new s(this.option.handshakeTimeout)),this.destroy()}),this.option.handshakeTimeout)}connectDone(e,t){super.connectDone(e,t),clearInterval(this.handshakeInterval),clearTimeout(this.handshakeTimeout),c(this.handshakeQueue,this.doPostMessage.bind(this))}receiveMessage(e){let t=super.receiveMessage(e);t&&(this.emit(t.name,t),this.emit(h,t))}setTargetWindow(e){return this.targetWindow=e,this.connected=!1,this.connectedPromise=new Promise(((e,t)=>{this.tryHandshake(e,t)})),this.connectedPromise}disconnect(){this.targetWindow=null,this.connected=!1}}class m{constructor(){this.handlers=[]}use(e){return this.handlers.push(e),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}walk(e){let t=e;return this.handlers.forEach((function(e){null!==e&&(t=e(t))})),t}}let g=1;class k{constructor(e,t){this.callbackMap={},this.interceptors=e,this.callback_timeout=t,this.key=(Math.random()+"").substr(2,8)}request(e,t,s){let n=g++;return e=this.interceptors.request.walk(Object.assign({__callbackId__:n},e)),this.callbackMap[n]={resolve:t,reject:s},setTimeout((()=>{this.callbackMap[n]&&(s(new a(this.callback_timeout)),delete this.callbackMap[n])}),this.callback_timeout),e}response(e){return e=this.interceptors.response.walk(e),this.callbackMap[e.callbackId]?(0===e.data.code?this.callbackMap[e.callbackId].resolve(e.data.data):this.callbackMap[e.callbackId].reject(e.data.msg),delete this.callbackMap[e.callbackId],e):e}}class v extends u{constructor(e){super(e),this.interceptors={request:new m,response:new m},this.callbackHandler=new k(this.interceptors,this.option.callbackTimeout)}connectDone(e,t){super.connectDone(e,t),this.targetWindow=t.source,this.handshake(),c(this.handshakeQueue,this.doPostMessage.bind(this))}fetch(e,t,s){return new Promise(((n,a)=>{var r;r=s,"[object Function]"===Object.prototype.toString.call(r)&&s((()=>a(new i)));let h=d.createAndValidate(e,t);h=this.callbackHandler.request(h,n,a),this.connected?this.doPostMessage(h):o(this.handshakeQueue,h,this.option.queueLimit)}))}receiveMessage(e){let t=super.receiveMessage(e);t&&(t.name&&(t.data.callbackId?t=this.callbackHandler.response(t.data):this.emit(t.name,t)),this.emit(h,t))}}class M extends e{constructor(e){super(e),this.option=Object.assign({},l,e),this.nsMap={},this.bridgeMap=new WeakMap,this.listenerSet=new Set,this.eventNameSet=new Set,this.send=this.postMessage,this.receiveMessage=this.receiveMessage.bind(this),window.addEventListener("message",this.receiveMessage,!1)}create(e,t){this.nsMap[e]&&this.destroy(e),this.nsMap[e]=t;let s=new p({namespace:e,targetWindow:t,proxyMode:!0});this.bridgeMap.set(t,s);for(let t of this.eventNameSet){let s=this.getListeners(t);s&&s.forEach((s=>{this.on(e+":"+t,s)}))}return s.connect()}on(e,t){if(!e)return;e.split(":")[1]?this.listenerSet.add(e):(this.eventNameSet.add(e),Object.keys(this.nsMap).forEach((s=>{let n=s+":"+e;super.on(n,t),this.listenerSet.add(n)}))),super.on(e,t)}postMessage(e,t){if(!e)return;let s=e.split(":");if(s[1]){let e,n=this.nsMap[s[0]];(e=this.bridgeMap.get(n))&&e.send(s[1],t)}else Object.keys(this.nsMap).forEach((s=>{this.bridgeMap.get(this.nsMap[s]).send(e,t)}))}receiveMessage(e){let t,s=e.source;if(!this.bridgeMap.has(s))return;try{t=JSON.parse(e.data)}catch(e){return}if(!t.__bridge_payload__)return;let n=this.bridgeMap.get(s);t.name!==r?(t.name&&this.emit(n.namespace+":"+t.name,Object.assign(t,{ns:n.namespace})),this.emit(h,t)):n.handshakeResponseHandler&&n.handshakeResponseHandler(e)}destroy(){window.removeEventListener("message",this.receiveMessage,!1)}disconnect(e){if(Array.isArray(e))return void e.forEach((e=>{this.disconnect(e)}));if(!this.nsMap[e])return;let t=this.nsMap[e];delete this.nsMap[e],t&&this.bridgeMap.delete(t);for(let t of this.listenerSet){t.split(":")[0]===e&&(this.listenerSet.delete(t),this.off(t))}}}export{M as BridgeManager,v as EmbedBridge,p as HostBridge};
